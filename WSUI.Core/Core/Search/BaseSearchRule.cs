///////////////////////////////////////////////////////////
//  BaseSearchRule.cs
//  Implementation of the Class BaseSearchRule
//  Generated by Enterprise Architect
//  Created on:      27-Sep-2013 11:34:46 PM
//  Original author: Yariki
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Nest;
using OF.Core.Core.AdvancedSearchCriteria;
using OF.Core.Core.ElasticSearch;
using OF.Core.Core.Rules;
using OF.Core.Data.ElasticSearch;
using OF.Core.Data.ElasticSearch.Request;
using OF.Core.ElasticSearch.Clients;
using OF.Core.Enums;
using OF.Core.Extensions;
using OF.Core.Interfaces;
using OF.Core.Logger;
using OF.Core.Utils;

namespace OF.Core.Core.Search
{
    public abstract class BaseSearchRule<T, E> : ISearch, ISearchRule
        where T : class, ISearchObject, new()
        where E : class, IElasticSearchObject, new()
    {
        #region [needs private]

        private Thread _ruleThread;
        private IQueryReader _reader;
        private volatile bool _isSearching = false;
        private bool _exludeIgnored = false;
        private OFElasticSearchClient _elasticSearchClient;
        private Func<T> _create;
        private int _from = 0;
        private long _total = 0;
        private List<string> _keywords;

        #endregion [needs private]

        #region [needs protected]

        protected volatile bool IsInterupt = false;
        protected IList<T> Result;
        protected bool NeedInterrup;
        protected DateTime LastDate;
        protected IEnumerable<IAdvancedSearchCriteria> AdvancedSearchCriterias;
        protected string Query;
        protected AutoResetEvent Event;
        protected int TopQueryResult = 100;
        protected int CountFirstProcess = 35;
        protected int CountSecondProcess = 7;
        protected int CountAdded = 0;
        protected volatile bool NeedStop = false;
        protected volatile object Lock = null;



        private volatile object _internalLock = new object();

        // results
        private TypeResult _typeResult;

        private IList<IResultMessage> _listMessage;

        protected string QueryAnd = " AND \"{0}*\"";

        protected string RuleName;

        #endregion [needs protected]

        protected BaseSearchRule()
            : this(null, false)
        {

        }

        protected BaseSearchRule(object lockObject, bool exludeIgnored)
        {
            Event = new AutoResetEvent(false);
            Result = new List<T>();
            Lock = lockObject ?? new object();
            _exludeIgnored = exludeIgnored;
            _elasticSearchClient = new OFElasticSearchClient();
            _create = New<T>.Instance;
        }

        public ISearchResult GetResults()
        {
            return new SearchResult(_typeResult, _listMessage.ToList(), (IEnumerable<ISearchObject>)Result);
        }

        /// <summary>
        /// @param ="criteris"
        /// </summary>
        /// <param name="crieria"></param>
        public virtual void SetSearchCriteria(string criteria)
        {
            Query = criteria.ToLowerInvariant().Trim();
            _keywords = GetProcessingSearchCriteria();
        }

        public virtual void SetAdvancedSearchCriteria(IEnumerable<IAdvancedSearchCriteria> advancedSearchCriterias)
        {
            AdvancedSearchCriterias = advancedSearchCriterias;
        }

        public void Search()
        {
            if (_isSearching)
            {
                Event.Set();
                return;
            }
            InitBeforeSearching();
            _ruleThread = new Thread(DoQuery) { Priority = ThreadPriority.Highest, Name = string.Format("{0}({1})", this.GetType().Name, typeof(T).Name) };
            _ruleThread.Start();
        }

        public virtual void Stop()
        {
            NeedStop = true;
        }

        protected virtual void DoQuery()
        {
            try
            {
                _isSearching = true;
                string query = Query;
                if (string.IsNullOrEmpty(query))
                    throw new ArgumentNullException("Query is null or empty");
                OFLogger.Instance.LogDebug("Query<{0}>: {1}", typeof(T).Name, query);


                if (_total != 0 && _from >= _total)
                {
                    return;
                }

                Stopwatch watch = new Stopwatch();
                watch.Start();

                IRawSearchResult<E> result = null;

                var body = GetSearchBody();
                if (body.IsNotNull())
                {
                    body.from = _from;
                    body.size = TopQueryResult;
                    result = _elasticSearchClient.RawSearch<E>(body);
                }

                watch.Stop();



                // additional process
                if (!NeedStop && result != null && result.Documents.Any())
                {
                    OFLogger.Instance.LogDebug("Search Done: Server {0}ms, Client {1}ms", result.Took, watch.ElapsedMilliseconds);
                    _total = result.Total;
                    _from += result.Documents.Count() == TopQueryResult ? TopQueryResult : result.Documents.Count();
                    watch = new Stopwatch();
                    watch.Start();
                    ReadDataFromTable(result.Documents);
                    watch.Stop();
                    OFLogger.Instance.LogDebug("Read Data Done: {0}ms", watch.ElapsedMilliseconds);

                    watch = new Stopwatch();
                    watch.Start();
                    ProcessResult();
                    watch.Stop();
                    OFLogger.Instance.LogDebug("Process Result Done: {0}ms", watch.ElapsedMilliseconds);

                    _typeResult = TypeResult.Ok;

                }
                else
                {
                    _typeResult = TypeResult.Error;
                    _listMessage.Add(new ResultMessage() { Message = "Rule was stoped" });
                }
            }
            catch (Exception ex)
            {
                _typeResult = TypeResult.Error;
                _listMessage.Add(new ResultMessage() { Message = ex.Message });
                OFLogger.Instance.LogError("Search <{0}>: {1}", typeof(T).Name, ex.Message);
            }
            finally
            {
                CountAdded = 0;
                TopQueryResult = CountSecondProcess;
                _isSearching = false;
                NeedStop = false;
                IsInterupt = false;
                IsInit = false;
                Event.Set();
            }
        }

        protected virtual IFieldSort BuildSortSelector(SortFieldDescriptor<E> sortFieldDescriptor)
        {
            return default(IFieldSort);
        }

        protected virtual IFieldSort BuildAdvancedFieldSortSortSelector(SortFieldDescriptor<E> sortFieldDescriptor)
        {
            return default(IFieldSort);
        }

        protected virtual QueryContainer BuildQuery(QueryDescriptor<E> queryDescriptor)
        {
            return default(QueryContainer);
        }

        protected virtual QueryContainer BuildAdvancedQuery(QueryDescriptor<E> queryDescriptor)
        {
            return default(QueryContainer);
        }

        protected virtual OFBody GetSearchBody()
        {
            return null;
        }

        protected virtual DataTable GetDataTable(string query)
        {
            return IndexerDataReader.Instance.GetDataByAdapter(query);
        }

        protected bool IsInit { get; private set; }

        protected virtual void ReadDataFromTable(IEnumerable<E> data)
        {
            Parallel.ForEach(data.AsEnumerable(), ReadData);
        }

        ///
        /// <param name="reader"></param>
        private void ReadData(E searchObject)
        {
            var result = _create.Invoke() as T;
            if (result == null)
                return;
            result.SetDataObject(searchObject);
            lock (_internalLock)
            {
                Result.Add(result);
                ProcessCountAdded();
            }
        }

        protected virtual void ProcessCountAdded()
        {
            CountAdded++;
        }

        public AutoResetEvent GetEvent()
        {
            Event.Reset();
            return Event;
        }

        public virtual void Reset()
        {
            CountAdded = 0;
            _from = 0;
            _total = 0;
            TopQueryResult = CountFirstProcess;
            Query = string.Empty;
            LastDate = GetCurrentDateTime();
            IsInterupt = false;
            NeedStop = false;
            IsInit = true;
            Result.Clear();
        }

        public bool IsSearching { get { return _isSearching; } }

        public int Priority { get; protected set; }

        public RuleObjectType ObjectType { get; protected set; }

        protected virtual void ProcessResult()
        {
        }

        protected virtual bool NeedSorting
        {
            get { return true; }
        }

        public virtual void Init()
        {
            _from = 0;
            _total = 0;
            LastDate = GetCurrentDateTime();
            TopQueryResult = CountFirstProcess;
            CountAdded = 0;
            _typeResult = TypeResult.None;
            _listMessage = new List<IResultMessage>();
            IsInit = true;
        }

        public void SetProcessingRecordCount(int first, int second)
        {
            TopQueryResult = CountFirstProcess = first;
            CountSecondProcess = second;
        }

        public bool IsAdvancedMode { get; set; }
        public bool IncludedInAdvancedMode { get { return GetIncludedInAdvancedMode(); } }

        protected virtual bool GetIncludedInAdvancedMode()
        {
            return false;
        }

        protected DateTime GetCurrentDateTime()
        {
            return DateTime.Now.AddDays(1);
        }

        protected IList<string> GetKeywordsList()
        {
            return _keywords;
        }

        protected string FormatDate(ref DateTime date)
        {
            return date.ToString("yyyy/MM/dd hh:mm:ss").Replace('.', '/');
        }

        protected string FormatCriteria(string criteria)
        {
            return string.Format("{0}*", criteria);
        }

        protected List<string> GetProcessingSearchCriteria(string keyword = "")
        {
            IList<IRule> listRuleCriteriasRules = RuleFactory.Instance.GetAllRules();
            var tempCriteria = string.IsNullOrEmpty(keyword) ? Query : keyword;
            var listW = new List<string>();

            foreach (var rule in listRuleCriteriasRules.OrderBy(i => i.Priority))
            {
                listW.AddRange(rule.ApplyRule(tempCriteria));
                tempCriteria = rule.ClearCriteriaAccordingRule(tempCriteria);
            }
            return listW;
        }

        protected virtual void InitBeforeSearching()
        {
            _typeResult = TypeResult.None;
            _listMessage.Clear();
            Result.Clear();
        }

    }//end BaseSearchRule
}//end namespace Search