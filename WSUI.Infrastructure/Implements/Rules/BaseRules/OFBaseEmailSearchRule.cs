///////////////////////////////////////////////////////////
//  BaseEmailSearchRule.cs
//  Implementation of the Class BaseEmailSearchRule
//  Generated by Enterprise Architect
//  Created on:      03-Oct-2013 8:49:17 PM
//  Original author: Yariki
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Documents;
using Microsoft.Practices.Unity;
using Nest;
using OF.Core.Core.Search;
using OF.Core.Data;
using OF.Core.Data.ElasticSearch;
using OF.Core.Data.ElasticSearch.Request;
using OF.Core.Data.ElasticSearch.Request.Email;
using OF.Core.Enums;
using OF.Core.Interfaces;
using OF.Core.Logger;

namespace OF.Infrastructure.Implements.Rules.BaseRules
{
    public abstract class OFBaseEmailSearchRule : BaseSearchRule<OFEmailSearchObject, OFEmail>, IEmailSearchRule
    {

        #region [needs]

        private readonly List<string> _listID = new List<string>();

        #endregion

        public OFBaseEmailSearchRule(IUnityContainer container)
            :this(null,container)
        {
        }

        public OFBaseEmailSearchRule(object lockObject, IUnityContainer container)
            : base(lockObject, false,container)
        {
        }

        public override void Init()
        {
            CountFirstProcess = 75;
            CountSecondProcess = 50;
            ObjectType = RuleObjectType.Email;
            base.Init();
        }

        public override void Reset()
        {
            _listID.Clear();
            base.Reset();
        }

        protected override QueryContainer BuildQuery(QueryDescriptor<OFEmail> queryDescriptor)
        {
            var preparedCriterias = GetKeywordsList();
            if (preparedCriterias.Count > 1)
            {
                return queryDescriptor.Bool(descriptor =>
                {
                    descriptor.Must(preparedCriterias.Select(preparedCriteria => (Func<QueryDescriptor<OFEmail>, QueryContainer>) (descriptor1 => descriptor1.Term(GetSearchedProperty(), preparedCriteria))).ToArray());
                });
            }
            return queryDescriptor.Term(GetSearchedProperty(), Query);
        }

        protected override IFieldSort BuildSortSelector(SortFieldDescriptor<OFEmail> sortFieldDescriptor)
        {
            return sortFieldDescriptor.OnField(e => e.Datecreated).Descending();
        }

        protected abstract Expression<Func<OFEmail, string>> GetSearchedProperty();

        protected override void ProcessResult()
        {
            IEnumerable<IGrouping<string, OFEmailSearchObject>> groped = null;

            if (!IsAdvancedMode)
                groped = Result.OrderByDescending(e => e.DateReceived).GroupBy(e => e.OutlookConversationId);
            else
                groped = GetSortedResult(Result);

            var result = new List<OFEmailSearchObject>();
            foreach (var group in groped)
            {
                var convIndex = group.GroupBy(i => i.ConversationIndex);
                if (!convIndex.Any())
                    continue;
                var data = convIndex.FirstOrDefault().First();
                if (data == null || string.IsNullOrEmpty(data.OutlookConversationId) || _listID.Contains(data.OutlookConversationId))
                    continue;
                _listID.Add(data.OutlookConversationId);
                foreach (var emailSearchObject in convIndex.Skip(1))
                {
                    data.AddItem(emailSearchObject.First());
                }
                result.Add(data);
            }
            Result.Clear();
            if (result.Count > 0)
            {
                OFLogger.Instance.LogDebug("{0}: {1}", RuleName, result.Count);
                Result = result;
                LastDate = Result.Last().DateReceived;
            }
        }

        private IEnumerable<IGrouping<string, OFEmailSearchObject>> GetSortedResult(IList<OFEmailSearchObject> result)
        {
            if (AdvancedSearchCriterias.All(c => c.CriteriaType != AdvancedSearchCriteriaType.SortBy))
                return result.GroupBy(e => e.OutlookConversationId);
            var sort = (AdvancedSearchSortByType)AdvancedSearchCriterias.First(c => c.CriteriaType == AdvancedSearchCriteriaType.SortBy).Value;
            switch (sort)
            {
                case AdvancedSearchSortByType.NewestToOldest:
                    return result.OrderByDescending(i => i.DateReceived).GroupBy(e => e.OutlookConversationId);
                case AdvancedSearchSortByType.OldestToNewest:
                    return result.OrderBy(i => i.DateReceived).GroupBy(e => e.OutlookConversationId);
                default:
                    return result.GroupBy(e => e.OutlookConversationId);
            }
        }

        public IEnumerable<string> GetConversationId()
        {
            return Result.Select(e => e.OutlookConversationId);
        }

        public void ApplyFilter(IEnumerable<string> conversationIds)
        {
            if (conversationIds == null || !conversationIds.Any())
                return;
            for (int i = 0; i < Result.Count; i++)
            {
                var obj = Result[i];
                if (conversationIds.Contains(obj.OutlookConversationId))
                {
                    Result.Remove(obj);
                    i--;
                }
            }
        }

    }//end BaseEmailSearchRule

}//end namespace Implements