///////////////////////////////////////////////////////////
//  AttachmentFilenameSearchRule.cs
//  Implementation of the Class AttachmentFilenameSearchRule
//  Generated by Enterprise Architect
//  Created on:      29-Sep-2013 10:41:43 AM
//  Original author: Yariki
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using Microsoft.Practices.Unity;
using Nest;
using OF.Core.Core.Rules;
using OF.Core.Core.Search;
using OF.Core.Data;
using OF.Core.Data.ElasticSearch;
using OF.Core.Enums;
using OF.Core.Logger;
using OF.Core.Utils;
using OF.Infrastructure.Service.Helpers;

namespace OF.Infrastructure.Implements.Rules.BaseRules 
{
	public class OFBaseAttachmentSearchRule : BaseSearchRule<OFAttachmentContentSearchObject,OFAttachmentContent>
	{

		public OFBaseAttachmentSearchRule(IUnityContainer container)
            :base(null,true,container)
		{
		    
		}

        public OFBaseAttachmentSearchRule(object lockOject, IUnityContainer container)
            :base(lockOject,true,container)
        {
            
        }

        protected virtual string GetSearchProperty()
        {
            return "*"; // searching in all property
        }

        protected override QueryContainer BuildQuery(QueryDescriptor<OFAttachmentContent> queryDescriptor)
        {
            var preparedCriterias = GetKeywordsList();
            if (preparedCriterias.Count > 1)
            {
                return queryDescriptor.Bool(descriptor =>
                {
                    descriptor.Must(preparedCriterias.Select(preparedCriteria => (Func<QueryDescriptor<OFAttachmentContent>, QueryContainer>)(descriptor1 => descriptor1.Term(GetSearchedProperty(), preparedCriteria))).ToArray());
                });
            }
            return queryDescriptor.Term(GetSearchedProperty(), Query);
        }

        protected virtual Expression<Func<OFAttachmentContent, string>> GetSearchedProperty()
        {
            return null;
        }

	    protected override bool NeedSorting
	    {
	        get { return false; }
	    }

	    public override void Init()
	    {
            InitCounts();
            ObjectType = RuleObjectType.File;
	        base.Init();
	    }

        protected virtual void InitCounts()
        {
            CountFirstProcess = 50;
            CountSecondProcess = 20;
        }

        protected override void ProcessCountAdded()
	    {
            CountAdded = Result.GroupBy(i => new { Name = i.ItemNameDisplay, Size = i.Size }).Count();
	    }

	    protected override void ProcessResult()
	    {
            var groups = Result.GroupBy(i => new { Name = i.ItemNameDisplay, Size = i.Size });
	        var result = new List<OFAttachmentContentSearchObject>();
            OFLogger.Instance.LogDebug(string.Format("Count attachments: {0}", groups.Count()));
            foreach (var group in groups)
            {
                var item = group.FirstOrDefault();
                OFTypeSearchItem type = OFSearchItemHelper.GetTypeItem(item.ItemUrl, item.Kind != null && item.Kind.Length > 0 ? item.Kind[0].ToString() : string.Empty);
                foreach (var attachmentSearchObject in group.Skip(1))
                {
                    item.AddItem(attachmentSearchObject);
                }
                result.Add(item);
            }
            Result.Clear();
            if (result.Count > 0)
            {
                OFLogger.Instance.LogDebug("{0}: {1}",RuleName,result.Count);
                Result = result;
                //LastDate = Result.Min(d => d.DateReceived); // TODO should be re-factored
            }
	    }

	    protected virtual IEnumerable<OFAttachmentSearchObject> GetSortedAttachmentSearchObjects(IEnumerable<OFAttachmentSearchObject> list)
	    {
	        return list.OrderByDescending(d => d.DateReceived);
	    }

	}//end AttachmentFilenameSearchRule

}//end namespace Implements